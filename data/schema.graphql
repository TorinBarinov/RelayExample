schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""An object with globally unique ID"""
interface Node {
  """A globally unique identifier"""
  id: ID!
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar

  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar

  """does the column NOT match the given pattern"""
  _nlike: bpchar

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar

  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

"""
columns and relationships of "estimate"
"""
type estimate implements Node {
  created_at: timestamptz!
  format: bpchar!
  id: ID!
  max: numeric!
  max_probability: float8!
  min: numeric!
  min_probability: float8!
  pk: uuid!

  """An array relationship"""
  progresses(
    """distinct select on columns"""
    distinct_on: [progress_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): [progress!]!

  """An aggregate relationship"""
  progresses_aggregate(
    """distinct select on columns"""
    distinct_on: [progress_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): progress_aggregate!

  """An array relationship connection"""
  progresses_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [progress_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): progressConnection!

  """An object relationship"""
  task: task!
  task_pk: uuid!
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_pk: uuid!
}

"""
A Relay connection object on "estimate"
"""
type estimateConnection {
  edges: [estimateEdge!]!
  pageInfo: PageInfo!
}

type estimateEdge {
  cursor: String!
  node: estimate!
}

"""
aggregated selection of "estimate"
"""
type estimate_aggregate {
  aggregate: estimate_aggregate_fields
  nodes: [estimate!]!
}

"""
aggregate fields of "estimate"
"""
type estimate_aggregate_fields {
  avg: estimate_avg_fields
  count(columns: [estimate_select_column!], distinct: Boolean): Int!
  max: estimate_max_fields
  min: estimate_min_fields
  stddev: estimate_stddev_fields
  stddev_pop: estimate_stddev_pop_fields
  stddev_samp: estimate_stddev_samp_fields
  sum: estimate_sum_fields
  var_pop: estimate_var_pop_fields
  var_samp: estimate_var_samp_fields
  variance: estimate_variance_fields
}

"""
order by aggregate values of table "estimate"
"""
input estimate_aggregate_order_by {
  avg: estimate_avg_order_by
  count: order_by
  max: estimate_max_order_by
  min: estimate_min_order_by
  stddev: estimate_stddev_order_by
  stddev_pop: estimate_stddev_pop_order_by
  stddev_samp: estimate_stddev_samp_order_by
  sum: estimate_sum_order_by
  var_pop: estimate_var_pop_order_by
  var_samp: estimate_var_samp_order_by
  variance: estimate_variance_order_by
}

"""
input type for inserting array relation for remote table "estimate"
"""
input estimate_arr_rel_insert_input {
  data: [estimate_insert_input!]!

  """upsert condition"""
  on_conflict: estimate_on_conflict
}

"""aggregate avg on columns"""
type estimate_avg_fields {
  max: Float
  max_probability: Float
  min: Float
  min_probability: Float
}

"""
order by avg() on columns of table "estimate"
"""
input estimate_avg_order_by {
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
}

"""
Boolean expression to filter rows from the table "estimate". All fields are combined with a logical 'AND'.
"""
input estimate_bool_exp {
  _and: [estimate_bool_exp!]
  _not: estimate_bool_exp
  _or: [estimate_bool_exp!]
  created_at: timestamptz_comparison_exp
  format: bpchar_comparison_exp
  max: numeric_comparison_exp
  max_probability: float8_comparison_exp
  min: numeric_comparison_exp
  min_probability: float8_comparison_exp
  pk: uuid_comparison_exp
  progresses: progress_bool_exp
  task: task_bool_exp
  task_pk: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_pk: uuid_comparison_exp
}

"""
unique or primary key constraints on table "estimate"
"""
enum estimate_constraint {
  """
  unique or primary key constraint on columns "pk"
  """
  estimate_pkey
}

"""
input type for incrementing numeric columns in table "estimate"
"""
input estimate_inc_input {
  max: numeric
  max_probability: float8
  min: numeric
  min_probability: float8
}

"""
input type for inserting data into table "estimate"
"""
input estimate_insert_input {
  created_at: timestamptz
  format: bpchar
  max: numeric
  max_probability: float8
  min: numeric
  min_probability: float8
  pk: uuid
  progresses: progress_arr_rel_insert_input
  task: task_obj_rel_insert_input
  task_pk: uuid
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_pk: uuid
}

"""aggregate max on columns"""
type estimate_max_fields {
  created_at: timestamptz
  format: bpchar
  max: numeric
  max_probability: float8
  min: numeric
  min_probability: float8
  pk: uuid
  task_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by max() on columns of table "estimate"
"""
input estimate_max_order_by {
  created_at: order_by
  format: order_by
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
  pk: order_by
  task_pk: order_by
  updated_at: order_by
  user_pk: order_by
}

"""aggregate min on columns"""
type estimate_min_fields {
  created_at: timestamptz
  format: bpchar
  max: numeric
  max_probability: float8
  min: numeric
  min_probability: float8
  pk: uuid
  task_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by min() on columns of table "estimate"
"""
input estimate_min_order_by {
  created_at: order_by
  format: order_by
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
  pk: order_by
  task_pk: order_by
  updated_at: order_by
  user_pk: order_by
}

"""
response of any mutation on the table "estimate"
"""
type estimate_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [estimate!]!
}

"""
input type for inserting object relation for remote table "estimate"
"""
input estimate_obj_rel_insert_input {
  data: estimate_insert_input!

  """upsert condition"""
  on_conflict: estimate_on_conflict
}

"""
on_conflict condition type for table "estimate"
"""
input estimate_on_conflict {
  constraint: estimate_constraint!
  update_columns: [estimate_update_column!]! = []
  where: estimate_bool_exp
}

"""Ordering options when selecting data from "estimate"."""
input estimate_order_by {
  created_at: order_by
  format: order_by
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
  pk: order_by
  progresses_aggregate: progress_aggregate_order_by
  task: task_order_by
  task_pk: order_by
  updated_at: order_by
  user: user_order_by
  user_pk: order_by
}

"""primary key columns input for table: estimate"""
input estimate_pk_columns_input {
  pk: uuid!
}

"""
select columns of table "estimate"
"""
enum estimate_select_column {
  """column name"""
  created_at

  """column name"""
  format

  """column name"""
  max

  """column name"""
  max_probability

  """column name"""
  min

  """column name"""
  min_probability

  """column name"""
  pk

  """column name"""
  task_pk

  """column name"""
  updated_at

  """column name"""
  user_pk
}

"""
input type for updating data in table "estimate"
"""
input estimate_set_input {
  created_at: timestamptz
  format: bpchar
  max: numeric
  max_probability: float8
  min: numeric
  min_probability: float8
  pk: uuid
  task_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""aggregate stddev on columns"""
type estimate_stddev_fields {
  max: Float
  max_probability: Float
  min: Float
  min_probability: Float
}

"""
order by stddev() on columns of table "estimate"
"""
input estimate_stddev_order_by {
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
}

"""aggregate stddev_pop on columns"""
type estimate_stddev_pop_fields {
  max: Float
  max_probability: Float
  min: Float
  min_probability: Float
}

"""
order by stddev_pop() on columns of table "estimate"
"""
input estimate_stddev_pop_order_by {
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
}

"""aggregate stddev_samp on columns"""
type estimate_stddev_samp_fields {
  max: Float
  max_probability: Float
  min: Float
  min_probability: Float
}

"""
order by stddev_samp() on columns of table "estimate"
"""
input estimate_stddev_samp_order_by {
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
}

"""aggregate sum on columns"""
type estimate_sum_fields {
  max: numeric
  max_probability: float8
  min: numeric
  min_probability: float8
}

"""
order by sum() on columns of table "estimate"
"""
input estimate_sum_order_by {
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
}

"""
update columns of table "estimate"
"""
enum estimate_update_column {
  """column name"""
  created_at

  """column name"""
  format

  """column name"""
  max

  """column name"""
  max_probability

  """column name"""
  min

  """column name"""
  min_probability

  """column name"""
  pk

  """column name"""
  task_pk

  """column name"""
  updated_at

  """column name"""
  user_pk
}

input estimate_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: estimate_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: estimate_set_input
  where: estimate_bool_exp!
}

"""aggregate var_pop on columns"""
type estimate_var_pop_fields {
  max: Float
  max_probability: Float
  min: Float
  min_probability: Float
}

"""
order by var_pop() on columns of table "estimate"
"""
input estimate_var_pop_order_by {
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
}

"""aggregate var_samp on columns"""
type estimate_var_samp_fields {
  max: Float
  max_probability: Float
  min: Float
  min_probability: Float
}

"""
order by var_samp() on columns of table "estimate"
"""
input estimate_var_samp_order_by {
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
}

"""aggregate variance on columns"""
type estimate_variance_fields {
  max: Float
  max_probability: Float
  min: Float
  min_probability: Float
}

"""
order by variance() on columns of table "estimate"
"""
input estimate_variance_order_by {
  max: order_by
  max_probability: order_by
  min: order_by
  min_probability: order_by
}

"""
columns and relationships of "fcm_token"
"""
type fcm_token implements Node {
  created_at: timestamptz!
  id: ID!
  pk: uuid!
  token: String!
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_pk: uuid!
}

"""
A Relay connection object on "fcm_token"
"""
type fcm_tokenConnection {
  edges: [fcm_tokenEdge!]!
  pageInfo: PageInfo!
}

type fcm_tokenEdge {
  cursor: String!
  node: fcm_token!
}

"""
aggregated selection of "fcm_token"
"""
type fcm_token_aggregate {
  aggregate: fcm_token_aggregate_fields
  nodes: [fcm_token!]!
}

"""
aggregate fields of "fcm_token"
"""
type fcm_token_aggregate_fields {
  count(columns: [fcm_token_select_column!], distinct: Boolean): Int!
  max: fcm_token_max_fields
  min: fcm_token_min_fields
}

"""
order by aggregate values of table "fcm_token"
"""
input fcm_token_aggregate_order_by {
  count: order_by
  max: fcm_token_max_order_by
  min: fcm_token_min_order_by
}

"""
input type for inserting array relation for remote table "fcm_token"
"""
input fcm_token_arr_rel_insert_input {
  data: [fcm_token_insert_input!]!

  """upsert condition"""
  on_conflict: fcm_token_on_conflict
}

"""
Boolean expression to filter rows from the table "fcm_token". All fields are combined with a logical 'AND'.
"""
input fcm_token_bool_exp {
  _and: [fcm_token_bool_exp!]
  _not: fcm_token_bool_exp
  _or: [fcm_token_bool_exp!]
  created_at: timestamptz_comparison_exp
  pk: uuid_comparison_exp
  token: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_pk: uuid_comparison_exp
}

"""
unique or primary key constraints on table "fcm_token"
"""
enum fcm_token_constraint {
  """
  unique or primary key constraint on columns "pk"
  """
  fcm_token_pkey

  """
  unique or primary key constraint on columns "token"
  """
  fcm_token_token_key
}

"""
input type for inserting data into table "fcm_token"
"""
input fcm_token_insert_input {
  created_at: timestamptz
  pk: uuid
  token: String
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_pk: uuid
}

"""aggregate max on columns"""
type fcm_token_max_fields {
  created_at: timestamptz
  pk: uuid
  token: String
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by max() on columns of table "fcm_token"
"""
input fcm_token_max_order_by {
  created_at: order_by
  pk: order_by
  token: order_by
  updated_at: order_by
  user_pk: order_by
}

"""aggregate min on columns"""
type fcm_token_min_fields {
  created_at: timestamptz
  pk: uuid
  token: String
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by min() on columns of table "fcm_token"
"""
input fcm_token_min_order_by {
  created_at: order_by
  pk: order_by
  token: order_by
  updated_at: order_by
  user_pk: order_by
}

"""
response of any mutation on the table "fcm_token"
"""
type fcm_token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [fcm_token!]!
}

"""
on_conflict condition type for table "fcm_token"
"""
input fcm_token_on_conflict {
  constraint: fcm_token_constraint!
  update_columns: [fcm_token_update_column!]! = []
  where: fcm_token_bool_exp
}

"""Ordering options when selecting data from "fcm_token"."""
input fcm_token_order_by {
  created_at: order_by
  pk: order_by
  token: order_by
  updated_at: order_by
  user: user_order_by
  user_pk: order_by
}

"""primary key columns input for table: fcm_token"""
input fcm_token_pk_columns_input {
  pk: uuid!
}

"""
select columns of table "fcm_token"
"""
enum fcm_token_select_column {
  """column name"""
  created_at

  """column name"""
  pk

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  user_pk
}

"""
input type for updating data in table "fcm_token"
"""
input fcm_token_set_input {
  created_at: timestamptz
  pk: uuid
  token: String
  updated_at: timestamptz
  user_pk: uuid
}

"""
update columns of table "fcm_token"
"""
enum fcm_token_update_column {
  """column name"""
  created_at

  """column name"""
  pk

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  user_pk
}

input fcm_token_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: fcm_token_set_input
  where: fcm_token_bool_exp!
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"""
columns and relationships of "integration_token"
"""
type integration_token implements Node {
  created_at: timestamptz!
  id: ID!
  pk: uuid!
  provider: String!
  token: String!
  updated_at: timestamptz!
  user_pk: uuid!
}

"""
A Relay connection object on "integration_token"
"""
type integration_tokenConnection {
  edges: [integration_tokenEdge!]!
  pageInfo: PageInfo!
}

type integration_tokenEdge {
  cursor: String!
  node: integration_token!
}

"""
aggregated selection of "integration_token"
"""
type integration_token_aggregate {
  aggregate: integration_token_aggregate_fields
  nodes: [integration_token!]!
}

"""
aggregate fields of "integration_token"
"""
type integration_token_aggregate_fields {
  count(columns: [integration_token_select_column!], distinct: Boolean): Int!
  max: integration_token_max_fields
  min: integration_token_min_fields
}

"""
order by aggregate values of table "integration_token"
"""
input integration_token_aggregate_order_by {
  count: order_by
  max: integration_token_max_order_by
  min: integration_token_min_order_by
}

"""
input type for inserting array relation for remote table "integration_token"
"""
input integration_token_arr_rel_insert_input {
  data: [integration_token_insert_input!]!

  """upsert condition"""
  on_conflict: integration_token_on_conflict
}

"""
Boolean expression to filter rows from the table "integration_token". All fields are combined with a logical 'AND'.
"""
input integration_token_bool_exp {
  _and: [integration_token_bool_exp!]
  _not: integration_token_bool_exp
  _or: [integration_token_bool_exp!]
  created_at: timestamptz_comparison_exp
  pk: uuid_comparison_exp
  provider: String_comparison_exp
  token: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_pk: uuid_comparison_exp
}

"""
unique or primary key constraints on table "integration_token"
"""
enum integration_token_constraint {
  """
  unique or primary key constraint on columns "pk"
  """
  integration_token_pkey
}

"""
input type for inserting data into table "integration_token"
"""
input integration_token_insert_input {
  created_at: timestamptz
  pk: uuid
  provider: String
  token: String
  updated_at: timestamptz
  user_pk: uuid
}

"""aggregate max on columns"""
type integration_token_max_fields {
  created_at: timestamptz
  pk: uuid
  provider: String
  token: String
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by max() on columns of table "integration_token"
"""
input integration_token_max_order_by {
  created_at: order_by
  pk: order_by
  provider: order_by
  token: order_by
  updated_at: order_by
  user_pk: order_by
}

"""aggregate min on columns"""
type integration_token_min_fields {
  created_at: timestamptz
  pk: uuid
  provider: String
  token: String
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by min() on columns of table "integration_token"
"""
input integration_token_min_order_by {
  created_at: order_by
  pk: order_by
  provider: order_by
  token: order_by
  updated_at: order_by
  user_pk: order_by
}

"""
response of any mutation on the table "integration_token"
"""
type integration_token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integration_token!]!
}

"""
on_conflict condition type for table "integration_token"
"""
input integration_token_on_conflict {
  constraint: integration_token_constraint!
  update_columns: [integration_token_update_column!]! = []
  where: integration_token_bool_exp
}

"""Ordering options when selecting data from "integration_token"."""
input integration_token_order_by {
  created_at: order_by
  pk: order_by
  provider: order_by
  token: order_by
  updated_at: order_by
  user_pk: order_by
}

"""primary key columns input for table: integration_token"""
input integration_token_pk_columns_input {
  pk: uuid!
}

"""
select columns of table "integration_token"
"""
enum integration_token_select_column {
  """column name"""
  created_at

  """column name"""
  pk

  """column name"""
  provider

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  user_pk
}

"""
input type for updating data in table "integration_token"
"""
input integration_token_set_input {
  created_at: timestamptz
  pk: uuid
  provider: String
  token: String
  updated_at: timestamptz
  user_pk: uuid
}

"""
update columns of table "integration_token"
"""
enum integration_token_update_column {
  """column name"""
  created_at

  """column name"""
  pk

  """column name"""
  provider

  """column name"""
  token

  """column name"""
  updated_at

  """column name"""
  user_pk
}

input integration_token_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: integration_token_set_input
  where: integration_token_bool_exp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "estimate"
  """
  delete_estimate(
    """filter the rows which have to be deleted"""
    where: estimate_bool_exp!
  ): estimate_mutation_response

  """
  delete single row from the table: "estimate"
  """
  delete_estimate_by_pk(pk: uuid!): estimate

  """
  delete data from the table: "fcm_token"
  """
  delete_fcm_token(
    """filter the rows which have to be deleted"""
    where: fcm_token_bool_exp!
  ): fcm_token_mutation_response

  """
  delete single row from the table: "fcm_token"
  """
  delete_fcm_token_by_pk(pk: uuid!): fcm_token

  """
  delete data from the table: "integration_token"
  """
  delete_integration_token(
    """filter the rows which have to be deleted"""
    where: integration_token_bool_exp!
  ): integration_token_mutation_response

  """
  delete single row from the table: "integration_token"
  """
  delete_integration_token_by_pk(pk: uuid!): integration_token

  """
  delete data from the table: "progress"
  """
  delete_progress(
    """filter the rows which have to be deleted"""
    where: progress_bool_exp!
  ): progress_mutation_response

  """
  delete single row from the table: "progress"
  """
  delete_progress_by_pk(pk: uuid!): progress

  """
  delete data from the table: "project"
  """
  delete_project(
    """filter the rows which have to be deleted"""
    where: project_bool_exp!
  ): project_mutation_response

  """
  delete single row from the table: "project"
  """
  delete_project_by_pk(pk: uuid!): project

  """
  delete data from the table: "task"
  """
  delete_task(
    """filter the rows which have to be deleted"""
    where: task_bool_exp!
  ): task_mutation_response

  """
  delete single row from the table: "task"
  """
  delete_task_by_pk(pk: uuid!): task

  """
  delete data from the table: "task_status"
  """
  delete_task_status(
    """filter the rows which have to be deleted"""
    where: task_status_bool_exp!
  ): task_status_mutation_response

  """
  delete single row from the table: "task_status"
  """
  delete_task_status_by_pk(status: String!): task_status

  """
  delete data from the table: "tenant"
  """
  delete_tenant(
    """filter the rows which have to be deleted"""
    where: tenant_bool_exp!
  ): tenant_mutation_response

  """
  delete single row from the table: "tenant"
  """
  delete_tenant_by_pk(pk: uuid!): tenant

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(pk: uuid!): user

  """
  delete data from the table: "user_project"
  """
  delete_user_project(
    """filter the rows which have to be deleted"""
    where: user_project_bool_exp!
  ): user_project_mutation_response

  """
  delete single row from the table: "user_project"
  """
  delete_user_project_by_pk(pk: uuid!): user_project

  """
  delete data from the table: "user_role"
  """
  delete_user_role(
    """filter the rows which have to be deleted"""
    where: user_role_bool_exp!
  ): user_role_mutation_response

  """
  delete single row from the table: "user_role"
  """
  delete_user_role_by_pk(role: String!): user_role

  """
  delete data from the table: "user_task"
  """
  delete_user_task(
    """filter the rows which have to be deleted"""
    where: user_task_bool_exp!
  ): user_task_mutation_response

  """
  delete single row from the table: "user_task"
  """
  delete_user_task_by_pk(pk: uuid!): user_task

  """
  delete data from the table: "user_tenant"
  """
  delete_user_tenant(
    """filter the rows which have to be deleted"""
    where: user_tenant_bool_exp!
  ): user_tenant_mutation_response

  """
  delete single row from the table: "user_tenant"
  """
  delete_user_tenant_by_pk(pk: uuid!): user_tenant

  """
  insert data into the table: "estimate"
  """
  insert_estimate(
    """the rows to be inserted"""
    objects: [estimate_insert_input!]!

    """upsert condition"""
    on_conflict: estimate_on_conflict
  ): estimate_mutation_response

  """
  insert a single row into the table: "estimate"
  """
  insert_estimate_one(
    """the row to be inserted"""
    object: estimate_insert_input!

    """upsert condition"""
    on_conflict: estimate_on_conflict
  ): estimate

  """
  insert data into the table: "fcm_token"
  """
  insert_fcm_token(
    """the rows to be inserted"""
    objects: [fcm_token_insert_input!]!

    """upsert condition"""
    on_conflict: fcm_token_on_conflict
  ): fcm_token_mutation_response

  """
  insert a single row into the table: "fcm_token"
  """
  insert_fcm_token_one(
    """the row to be inserted"""
    object: fcm_token_insert_input!

    """upsert condition"""
    on_conflict: fcm_token_on_conflict
  ): fcm_token

  """
  insert data into the table: "integration_token"
  """
  insert_integration_token(
    """the rows to be inserted"""
    objects: [integration_token_insert_input!]!

    """upsert condition"""
    on_conflict: integration_token_on_conflict
  ): integration_token_mutation_response

  """
  insert a single row into the table: "integration_token"
  """
  insert_integration_token_one(
    """the row to be inserted"""
    object: integration_token_insert_input!

    """upsert condition"""
    on_conflict: integration_token_on_conflict
  ): integration_token

  """
  insert data into the table: "progress"
  """
  insert_progress(
    """the rows to be inserted"""
    objects: [progress_insert_input!]!

    """upsert condition"""
    on_conflict: progress_on_conflict
  ): progress_mutation_response

  """
  insert a single row into the table: "progress"
  """
  insert_progress_one(
    """the row to be inserted"""
    object: progress_insert_input!

    """upsert condition"""
    on_conflict: progress_on_conflict
  ): progress

  """
  insert data into the table: "project"
  """
  insert_project(
    """the rows to be inserted"""
    objects: [project_insert_input!]!

    """upsert condition"""
    on_conflict: project_on_conflict
  ): project_mutation_response

  """
  insert a single row into the table: "project"
  """
  insert_project_one(
    """the row to be inserted"""
    object: project_insert_input!

    """upsert condition"""
    on_conflict: project_on_conflict
  ): project

  """
  insert data into the table: "task"
  """
  insert_task(
    """the rows to be inserted"""
    objects: [task_insert_input!]!

    """upsert condition"""
    on_conflict: task_on_conflict
  ): task_mutation_response

  """
  insert a single row into the table: "task"
  """
  insert_task_one(
    """the row to be inserted"""
    object: task_insert_input!

    """upsert condition"""
    on_conflict: task_on_conflict
  ): task

  """
  insert data into the table: "task_status"
  """
  insert_task_status(
    """the rows to be inserted"""
    objects: [task_status_insert_input!]!

    """upsert condition"""
    on_conflict: task_status_on_conflict
  ): task_status_mutation_response

  """
  insert a single row into the table: "task_status"
  """
  insert_task_status_one(
    """the row to be inserted"""
    object: task_status_insert_input!

    """upsert condition"""
    on_conflict: task_status_on_conflict
  ): task_status

  """
  insert data into the table: "tenant"
  """
  insert_tenant(
    """the rows to be inserted"""
    objects: [tenant_insert_input!]!

    """upsert condition"""
    on_conflict: tenant_on_conflict
  ): tenant_mutation_response

  """
  insert a single row into the table: "tenant"
  """
  insert_tenant_one(
    """the row to be inserted"""
    object: tenant_insert_input!

    """upsert condition"""
    on_conflict: tenant_on_conflict
  ): tenant

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user

  """
  insert data into the table: "user_project"
  """
  insert_user_project(
    """the rows to be inserted"""
    objects: [user_project_insert_input!]!

    """upsert condition"""
    on_conflict: user_project_on_conflict
  ): user_project_mutation_response

  """
  insert a single row into the table: "user_project"
  """
  insert_user_project_one(
    """the row to be inserted"""
    object: user_project_insert_input!

    """upsert condition"""
    on_conflict: user_project_on_conflict
  ): user_project

  """
  insert data into the table: "user_role"
  """
  insert_user_role(
    """the rows to be inserted"""
    objects: [user_role_insert_input!]!

    """upsert condition"""
    on_conflict: user_role_on_conflict
  ): user_role_mutation_response

  """
  insert a single row into the table: "user_role"
  """
  insert_user_role_one(
    """the row to be inserted"""
    object: user_role_insert_input!

    """upsert condition"""
    on_conflict: user_role_on_conflict
  ): user_role

  """
  insert data into the table: "user_task"
  """
  insert_user_task(
    """the rows to be inserted"""
    objects: [user_task_insert_input!]!

    """upsert condition"""
    on_conflict: user_task_on_conflict
  ): user_task_mutation_response

  """
  insert a single row into the table: "user_task"
  """
  insert_user_task_one(
    """the row to be inserted"""
    object: user_task_insert_input!

    """upsert condition"""
    on_conflict: user_task_on_conflict
  ): user_task

  """
  insert data into the table: "user_tenant"
  """
  insert_user_tenant(
    """the rows to be inserted"""
    objects: [user_tenant_insert_input!]!

    """upsert condition"""
    on_conflict: user_tenant_on_conflict
  ): user_tenant_mutation_response

  """
  insert a single row into the table: "user_tenant"
  """
  insert_user_tenant_one(
    """the row to be inserted"""
    object: user_tenant_insert_input!

    """upsert condition"""
    on_conflict: user_tenant_on_conflict
  ): user_tenant

  """
  update data of the table: "estimate"
  """
  update_estimate(
    """increments the numeric columns with given value of the filtered values"""
    _inc: estimate_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: estimate_set_input

    """filter the rows which have to be updated"""
    where: estimate_bool_exp!
  ): estimate_mutation_response

  """
  update single row of the table: "estimate"
  """
  update_estimate_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: estimate_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: estimate_set_input
    pk_columns: estimate_pk_columns_input!
  ): estimate

  """
  update multiples rows of table: "estimate"
  """
  update_estimate_many(
    """updates to execute, in order"""
    updates: [estimate_updates!]!
  ): [estimate_mutation_response]

  """
  update data of the table: "fcm_token"
  """
  update_fcm_token(
    """sets the columns of the filtered rows to the given values"""
    _set: fcm_token_set_input

    """filter the rows which have to be updated"""
    where: fcm_token_bool_exp!
  ): fcm_token_mutation_response

  """
  update single row of the table: "fcm_token"
  """
  update_fcm_token_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: fcm_token_set_input
    pk_columns: fcm_token_pk_columns_input!
  ): fcm_token

  """
  update multiples rows of table: "fcm_token"
  """
  update_fcm_token_many(
    """updates to execute, in order"""
    updates: [fcm_token_updates!]!
  ): [fcm_token_mutation_response]

  """
  update data of the table: "integration_token"
  """
  update_integration_token(
    """sets the columns of the filtered rows to the given values"""
    _set: integration_token_set_input

    """filter the rows which have to be updated"""
    where: integration_token_bool_exp!
  ): integration_token_mutation_response

  """
  update single row of the table: "integration_token"
  """
  update_integration_token_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: integration_token_set_input
    pk_columns: integration_token_pk_columns_input!
  ): integration_token

  """
  update multiples rows of table: "integration_token"
  """
  update_integration_token_many(
    """updates to execute, in order"""
    updates: [integration_token_updates!]!
  ): [integration_token_mutation_response]

  """
  update data of the table: "progress"
  """
  update_progress(
    """sets the columns of the filtered rows to the given values"""
    _set: progress_set_input

    """filter the rows which have to be updated"""
    where: progress_bool_exp!
  ): progress_mutation_response

  """
  update single row of the table: "progress"
  """
  update_progress_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: progress_set_input
    pk_columns: progress_pk_columns_input!
  ): progress

  """
  update multiples rows of table: "progress"
  """
  update_progress_many(
    """updates to execute, in order"""
    updates: [progress_updates!]!
  ): [progress_mutation_response]

  """
  update data of the table: "project"
  """
  update_project(
    """sets the columns of the filtered rows to the given values"""
    _set: project_set_input

    """filter the rows which have to be updated"""
    where: project_bool_exp!
  ): project_mutation_response

  """
  update single row of the table: "project"
  """
  update_project_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: project_set_input
    pk_columns: project_pk_columns_input!
  ): project

  """
  update multiples rows of table: "project"
  """
  update_project_many(
    """updates to execute, in order"""
    updates: [project_updates!]!
  ): [project_mutation_response]

  """
  update data of the table: "task"
  """
  update_task(
    """sets the columns of the filtered rows to the given values"""
    _set: task_set_input

    """filter the rows which have to be updated"""
    where: task_bool_exp!
  ): task_mutation_response

  """
  update single row of the table: "task"
  """
  update_task_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: task_set_input
    pk_columns: task_pk_columns_input!
  ): task

  """
  update multiples rows of table: "task"
  """
  update_task_many(
    """updates to execute, in order"""
    updates: [task_updates!]!
  ): [task_mutation_response]

  """
  update data of the table: "task_status"
  """
  update_task_status(
    """sets the columns of the filtered rows to the given values"""
    _set: task_status_set_input

    """filter the rows which have to be updated"""
    where: task_status_bool_exp!
  ): task_status_mutation_response

  """
  update single row of the table: "task_status"
  """
  update_task_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: task_status_set_input
    pk_columns: task_status_pk_columns_input!
  ): task_status

  """
  update multiples rows of table: "task_status"
  """
  update_task_status_many(
    """updates to execute, in order"""
    updates: [task_status_updates!]!
  ): [task_status_mutation_response]

  """
  update data of the table: "tenant"
  """
  update_tenant(
    """sets the columns of the filtered rows to the given values"""
    _set: tenant_set_input

    """filter the rows which have to be updated"""
    where: tenant_bool_exp!
  ): tenant_mutation_response

  """
  update single row of the table: "tenant"
  """
  update_tenant_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tenant_set_input
    pk_columns: tenant_pk_columns_input!
  ): tenant

  """
  update multiples rows of table: "tenant"
  """
  update_tenant_many(
    """updates to execute, in order"""
    updates: [tenant_updates!]!
  ): [tenant_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]

  """
  update data of the table: "user_project"
  """
  update_user_project(
    """sets the columns of the filtered rows to the given values"""
    _set: user_project_set_input

    """filter the rows which have to be updated"""
    where: user_project_bool_exp!
  ): user_project_mutation_response

  """
  update single row of the table: "user_project"
  """
  update_user_project_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_project_set_input
    pk_columns: user_project_pk_columns_input!
  ): user_project

  """
  update multiples rows of table: "user_project"
  """
  update_user_project_many(
    """updates to execute, in order"""
    updates: [user_project_updates!]!
  ): [user_project_mutation_response]

  """
  update data of the table: "user_role"
  """
  update_user_role(
    """sets the columns of the filtered rows to the given values"""
    _set: user_role_set_input

    """filter the rows which have to be updated"""
    where: user_role_bool_exp!
  ): user_role_mutation_response

  """
  update single row of the table: "user_role"
  """
  update_user_role_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_role_set_input
    pk_columns: user_role_pk_columns_input!
  ): user_role

  """
  update multiples rows of table: "user_role"
  """
  update_user_role_many(
    """updates to execute, in order"""
    updates: [user_role_updates!]!
  ): [user_role_mutation_response]

  """
  update data of the table: "user_task"
  """
  update_user_task(
    """sets the columns of the filtered rows to the given values"""
    _set: user_task_set_input

    """filter the rows which have to be updated"""
    where: user_task_bool_exp!
  ): user_task_mutation_response

  """
  update single row of the table: "user_task"
  """
  update_user_task_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_task_set_input
    pk_columns: user_task_pk_columns_input!
  ): user_task

  """
  update multiples rows of table: "user_task"
  """
  update_user_task_many(
    """updates to execute, in order"""
    updates: [user_task_updates!]!
  ): [user_task_mutation_response]

  """
  update data of the table: "user_tenant"
  """
  update_user_tenant(
    """sets the columns of the filtered rows to the given values"""
    _set: user_tenant_set_input

    """filter the rows which have to be updated"""
    where: user_tenant_bool_exp!
  ): user_tenant_mutation_response

  """
  update single row of the table: "user_tenant"
  """
  update_user_tenant_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_tenant_set_input
    pk_columns: user_tenant_pk_columns_input!
  ): user_tenant

  """
  update multiples rows of table: "user_tenant"
  """
  update_user_tenant_many(
    """updates to execute, in order"""
    updates: [user_tenant_updates!]!
  ): [user_tenant_mutation_response]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "progress"
"""
type progress implements Node {
  created_at: timestamptz!

  """An object relationship"""
  estimate: estimate!
  estimate_pk: uuid!
  id: ID!
  pk: uuid!

  """An object relationship"""
  task: task!
  task_pk: uuid!
  text: String!
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_pk: uuid!
}

"""
A Relay connection object on "progress"
"""
type progressConnection {
  edges: [progressEdge!]!
  pageInfo: PageInfo!
}

type progressEdge {
  cursor: String!
  node: progress!
}

"""
aggregated selection of "progress"
"""
type progress_aggregate {
  aggregate: progress_aggregate_fields
  nodes: [progress!]!
}

"""
aggregate fields of "progress"
"""
type progress_aggregate_fields {
  count(columns: [progress_select_column!], distinct: Boolean): Int!
  max: progress_max_fields
  min: progress_min_fields
}

"""
order by aggregate values of table "progress"
"""
input progress_aggregate_order_by {
  count: order_by
  max: progress_max_order_by
  min: progress_min_order_by
}

"""
input type for inserting array relation for remote table "progress"
"""
input progress_arr_rel_insert_input {
  data: [progress_insert_input!]!

  """upsert condition"""
  on_conflict: progress_on_conflict
}

"""
Boolean expression to filter rows from the table "progress". All fields are combined with a logical 'AND'.
"""
input progress_bool_exp {
  _and: [progress_bool_exp!]
  _not: progress_bool_exp
  _or: [progress_bool_exp!]
  created_at: timestamptz_comparison_exp
  estimate: estimate_bool_exp
  estimate_pk: uuid_comparison_exp
  pk: uuid_comparison_exp
  task: task_bool_exp
  task_pk: uuid_comparison_exp
  text: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_pk: uuid_comparison_exp
}

"""
unique or primary key constraints on table "progress"
"""
enum progress_constraint {
  """
  unique or primary key constraint on columns "pk"
  """
  progress_pkey
}

"""
input type for inserting data into table "progress"
"""
input progress_insert_input {
  created_at: timestamptz
  estimate: estimate_obj_rel_insert_input
  estimate_pk: uuid
  pk: uuid
  task: task_obj_rel_insert_input
  task_pk: uuid
  text: String
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_pk: uuid
}

"""aggregate max on columns"""
type progress_max_fields {
  created_at: timestamptz
  estimate_pk: uuid
  pk: uuid
  task_pk: uuid
  text: String
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by max() on columns of table "progress"
"""
input progress_max_order_by {
  created_at: order_by
  estimate_pk: order_by
  pk: order_by
  task_pk: order_by
  text: order_by
  updated_at: order_by
  user_pk: order_by
}

"""aggregate min on columns"""
type progress_min_fields {
  created_at: timestamptz
  estimate_pk: uuid
  pk: uuid
  task_pk: uuid
  text: String
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by min() on columns of table "progress"
"""
input progress_min_order_by {
  created_at: order_by
  estimate_pk: order_by
  pk: order_by
  task_pk: order_by
  text: order_by
  updated_at: order_by
  user_pk: order_by
}

"""
response of any mutation on the table "progress"
"""
type progress_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [progress!]!
}

"""
on_conflict condition type for table "progress"
"""
input progress_on_conflict {
  constraint: progress_constraint!
  update_columns: [progress_update_column!]! = []
  where: progress_bool_exp
}

"""Ordering options when selecting data from "progress"."""
input progress_order_by {
  created_at: order_by
  estimate: estimate_order_by
  estimate_pk: order_by
  pk: order_by
  task: task_order_by
  task_pk: order_by
  text: order_by
  updated_at: order_by
  user: user_order_by
  user_pk: order_by
}

"""primary key columns input for table: progress"""
input progress_pk_columns_input {
  pk: uuid!
}

"""
select columns of table "progress"
"""
enum progress_select_column {
  """column name"""
  created_at

  """column name"""
  estimate_pk

  """column name"""
  pk

  """column name"""
  task_pk

  """column name"""
  text

  """column name"""
  updated_at

  """column name"""
  user_pk
}

"""
input type for updating data in table "progress"
"""
input progress_set_input {
  created_at: timestamptz
  estimate_pk: uuid
  pk: uuid
  task_pk: uuid
  text: String
  updated_at: timestamptz
  user_pk: uuid
}

"""
update columns of table "progress"
"""
enum progress_update_column {
  """column name"""
  created_at

  """column name"""
  estimate_pk

  """column name"""
  pk

  """column name"""
  task_pk

  """column name"""
  text

  """column name"""
  updated_at

  """column name"""
  user_pk
}

input progress_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: progress_set_input
  where: progress_bool_exp!
}

"""
columns and relationships of "project"
"""
type project implements Node {
  created_at: timestamptz!
  description: String!
  id: ID!
  name: String!
  pk: uuid!

  """An array relationship"""
  tasks(
    """distinct select on columns"""
    distinct_on: [task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): [task!]!

  """An aggregate relationship"""
  tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): task_aggregate!

  """An array relationship connection"""
  tasks_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [task_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): taskConnection!

  """An object relationship"""
  tenant: tenant!
  tenant_pk: uuid!
  updated_at: timestamptz!

  """An array relationship"""
  user_projects(
    """distinct select on columns"""
    distinct_on: [user_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_project_order_by!]

    """filter the rows returned"""
    where: user_project_bool_exp
  ): [user_project!]!

  """An aggregate relationship"""
  user_projects_aggregate(
    """distinct select on columns"""
    distinct_on: [user_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_project_order_by!]

    """filter the rows returned"""
    where: user_project_bool_exp
  ): user_project_aggregate!

  """An array relationship connection"""
  user_projects_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_project_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_project_order_by!]

    """filter the rows returned"""
    where: user_project_bool_exp
  ): user_projectConnection!

  """An object relationship"""
  user_task: user_task
}

"""
A Relay connection object on "project"
"""
type projectConnection {
  edges: [projectEdge!]!
  pageInfo: PageInfo!
}

type projectEdge {
  cursor: String!
  node: project!
}

"""
aggregated selection of "project"
"""
type project_aggregate {
  aggregate: project_aggregate_fields
  nodes: [project!]!
}

"""
aggregate fields of "project"
"""
type project_aggregate_fields {
  count(columns: [project_select_column!], distinct: Boolean): Int!
  max: project_max_fields
  min: project_min_fields
}

"""
order by aggregate values of table "project"
"""
input project_aggregate_order_by {
  count: order_by
  max: project_max_order_by
  min: project_min_order_by
}

"""
input type for inserting array relation for remote table "project"
"""
input project_arr_rel_insert_input {
  data: [project_insert_input!]!

  """upsert condition"""
  on_conflict: project_on_conflict
}

"""
Boolean expression to filter rows from the table "project". All fields are combined with a logical 'AND'.
"""
input project_bool_exp {
  _and: [project_bool_exp!]
  _not: project_bool_exp
  _or: [project_bool_exp!]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  name: String_comparison_exp
  pk: uuid_comparison_exp
  tasks: task_bool_exp
  tenant: tenant_bool_exp
  tenant_pk: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_projects: user_project_bool_exp
  user_task: user_task_bool_exp
}

"""
unique or primary key constraints on table "project"
"""
enum project_constraint {
  """
  unique or primary key constraint on columns "pk"
  """
  project_pkey
}

"""
input type for inserting data into table "project"
"""
input project_insert_input {
  created_at: timestamptz
  description: String
  name: String
  pk: uuid
  tasks: task_arr_rel_insert_input
  tenant: tenant_obj_rel_insert_input
  tenant_pk: uuid
  updated_at: timestamptz
  user_projects: user_project_arr_rel_insert_input
  user_task: user_task_obj_rel_insert_input
}

"""aggregate max on columns"""
type project_max_fields {
  created_at: timestamptz
  description: String
  name: String
  pk: uuid
  tenant_pk: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "project"
"""
input project_max_order_by {
  created_at: order_by
  description: order_by
  name: order_by
  pk: order_by
  tenant_pk: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type project_min_fields {
  created_at: timestamptz
  description: String
  name: String
  pk: uuid
  tenant_pk: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "project"
"""
input project_min_order_by {
  created_at: order_by
  description: order_by
  name: order_by
  pk: order_by
  tenant_pk: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "project"
"""
type project_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [project!]!
}

"""
input type for inserting object relation for remote table "project"
"""
input project_obj_rel_insert_input {
  data: project_insert_input!

  """upsert condition"""
  on_conflict: project_on_conflict
}

"""
on_conflict condition type for table "project"
"""
input project_on_conflict {
  constraint: project_constraint!
  update_columns: [project_update_column!]! = []
  where: project_bool_exp
}

"""Ordering options when selecting data from "project"."""
input project_order_by {
  created_at: order_by
  description: order_by
  name: order_by
  pk: order_by
  tasks_aggregate: task_aggregate_order_by
  tenant: tenant_order_by
  tenant_pk: order_by
  updated_at: order_by
  user_projects_aggregate: user_project_aggregate_order_by
  user_task: user_task_order_by
}

"""primary key columns input for table: project"""
input project_pk_columns_input {
  pk: uuid!
}

"""
select columns of table "project"
"""
enum project_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  name

  """column name"""
  pk

  """column name"""
  tenant_pk

  """column name"""
  updated_at
}

"""
input type for updating data in table "project"
"""
input project_set_input {
  created_at: timestamptz
  description: String
  name: String
  pk: uuid
  tenant_pk: uuid
  updated_at: timestamptz
}

"""
update columns of table "project"
"""
enum project_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  name

  """column name"""
  pk

  """column name"""
  tenant_pk

  """column name"""
  updated_at
}

input project_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: project_set_input
  where: project_bool_exp!
}

type query_root {
  """
  fetch data from the table: "estimate"
  """
  estimate_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [estimate_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [estimate_order_by!]

    """filter the rows returned"""
    where: estimate_bool_exp
  ): estimateConnection!

  """
  fetch data from the table: "fcm_token"
  """
  fcm_token_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [fcm_token_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [fcm_token_order_by!]

    """filter the rows returned"""
    where: fcm_token_bool_exp
  ): fcm_tokenConnection!

  """
  fetch data from the table: "integration_token"
  """
  integration_token_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [integration_token_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [integration_token_order_by!]

    """filter the rows returned"""
    where: integration_token_bool_exp
  ): integration_tokenConnection!
  node(
    """A globally unique id"""
    id: ID!
  ): Node

  """
  fetch data from the table: "progress"
  """
  progress_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [progress_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): progressConnection!

  """
  fetch data from the table: "project"
  """
  project_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [project_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [project_order_by!]

    """filter the rows returned"""
    where: project_bool_exp
  ): projectConnection!

  """
  fetch data from the table: "task"
  """
  task_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [task_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): taskConnection!

  """
  fetch data from the table: "task_status"
  """
  task_status_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [task_status_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): task_statusConnection!

  """
  fetch data from the table: "tenant"
  """
  tenant_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [tenant_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): tenantConnection!

  """
  fetch data from the table: "user"
  """
  user_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): userConnection!

  """
  fetch data from the table: "user_project"
  """
  user_project_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_project_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_project_order_by!]

    """filter the rows returned"""
    where: user_project_bool_exp
  ): user_projectConnection!

  """
  fetch data from the table: "user_role"
  """
  user_role_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_role_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_role_order_by!]

    """filter the rows returned"""
    where: user_role_bool_exp
  ): user_roleConnection!

  """
  fetch data from the table: "user_task"
  """
  user_task_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_task_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): user_taskConnection!

  """
  fetch data from the table: "user_tenant"
  """
  user_tenant_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): user_tenantConnection!
}

type subscription_root {
  """
  fetch data from the table: "estimate"
  """
  estimate_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [estimate_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [estimate_order_by!]

    """filter the rows returned"""
    where: estimate_bool_exp
  ): estimateConnection!

  """
  fetch data from the table: "fcm_token"
  """
  fcm_token_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [fcm_token_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [fcm_token_order_by!]

    """filter the rows returned"""
    where: fcm_token_bool_exp
  ): fcm_tokenConnection!

  """
  fetch data from the table: "integration_token"
  """
  integration_token_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [integration_token_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [integration_token_order_by!]

    """filter the rows returned"""
    where: integration_token_bool_exp
  ): integration_tokenConnection!
  node(
    """A globally unique id"""
    id: ID!
  ): Node

  """
  fetch data from the table: "progress"
  """
  progress_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [progress_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): progressConnection!

  """
  fetch data from the table: "project"
  """
  project_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [project_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [project_order_by!]

    """filter the rows returned"""
    where: project_bool_exp
  ): projectConnection!

  """
  fetch data from the table: "task"
  """
  task_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [task_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [task_order_by!]

    """filter the rows returned"""
    where: task_bool_exp
  ): taskConnection!

  """
  fetch data from the table: "task_status"
  """
  task_status_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [task_status_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [task_status_order_by!]

    """filter the rows returned"""
    where: task_status_bool_exp
  ): task_statusConnection!

  """
  fetch data from the table: "tenant"
  """
  tenant_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [tenant_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): tenantConnection!

  """
  fetch data from the table: "user"
  """
  user_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): userConnection!

  """
  fetch data from the table: "user_project"
  """
  user_project_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_project_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_project_order_by!]

    """filter the rows returned"""
    where: user_project_bool_exp
  ): user_projectConnection!

  """
  fetch data from the table: "user_role"
  """
  user_role_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_role_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_role_order_by!]

    """filter the rows returned"""
    where: user_role_bool_exp
  ): user_roleConnection!

  """
  fetch data from the table: "user_task"
  """
  user_task_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_task_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): user_taskConnection!

  """
  fetch data from the table: "user_tenant"
  """
  user_tenant_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): user_tenantConnection!
}

"""
columns and relationships of "task"
"""
type task implements Node {
  created_at: timestamptz!
  description: String!

  """An array relationship"""
  estimates(
    """distinct select on columns"""
    distinct_on: [estimate_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [estimate_order_by!]

    """filter the rows returned"""
    where: estimate_bool_exp
  ): [estimate!]!

  """An aggregate relationship"""
  estimates_aggregate(
    """distinct select on columns"""
    distinct_on: [estimate_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [estimate_order_by!]

    """filter the rows returned"""
    where: estimate_bool_exp
  ): estimate_aggregate!

  """An array relationship connection"""
  estimates_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [estimate_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [estimate_order_by!]

    """filter the rows returned"""
    where: estimate_bool_exp
  ): estimateConnection!
  id: ID!
  pk: uuid!

  """An array relationship"""
  progresses(
    """distinct select on columns"""
    distinct_on: [progress_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): [progress!]!

  """An aggregate relationship"""
  progresses_aggregate(
    """distinct select on columns"""
    distinct_on: [progress_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): progress_aggregate!

  """An array relationship connection"""
  progresses_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [progress_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): progressConnection!

  """An object relationship"""
  project: project!
  project_pk: uuid!
  title: String!
  updated_at: timestamptz!

  """An array relationship"""
  user_tasks(
    """distinct select on columns"""
    distinct_on: [user_task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): [user_task!]!

  """An aggregate relationship"""
  user_tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [user_task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): user_task_aggregate!

  """An array relationship connection"""
  user_tasks_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_task_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): user_taskConnection!
}

"""
A Relay connection object on "task"
"""
type taskConnection {
  edges: [taskEdge!]!
  pageInfo: PageInfo!
}

type taskEdge {
  cursor: String!
  node: task!
}

"""
aggregated selection of "task"
"""
type task_aggregate {
  aggregate: task_aggregate_fields
  nodes: [task!]!
}

"""
aggregate fields of "task"
"""
type task_aggregate_fields {
  count(columns: [task_select_column!], distinct: Boolean): Int!
  max: task_max_fields
  min: task_min_fields
}

"""
order by aggregate values of table "task"
"""
input task_aggregate_order_by {
  count: order_by
  max: task_max_order_by
  min: task_min_order_by
}

"""
input type for inserting array relation for remote table "task"
"""
input task_arr_rel_insert_input {
  data: [task_insert_input!]!

  """upsert condition"""
  on_conflict: task_on_conflict
}

"""
Boolean expression to filter rows from the table "task". All fields are combined with a logical 'AND'.
"""
input task_bool_exp {
  _and: [task_bool_exp!]
  _not: task_bool_exp
  _or: [task_bool_exp!]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  estimates: estimate_bool_exp
  pk: uuid_comparison_exp
  progresses: progress_bool_exp
  project: project_bool_exp
  project_pk: uuid_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_tasks: user_task_bool_exp
}

"""
unique or primary key constraints on table "task"
"""
enum task_constraint {
  """
  unique or primary key constraint on columns "pk"
  """
  task_pkey
}

"""
input type for inserting data into table "task"
"""
input task_insert_input {
  created_at: timestamptz
  description: String
  estimates: estimate_arr_rel_insert_input
  pk: uuid
  progresses: progress_arr_rel_insert_input
  project: project_obj_rel_insert_input
  project_pk: uuid
  title: String
  updated_at: timestamptz
  user_tasks: user_task_arr_rel_insert_input
}

"""aggregate max on columns"""
type task_max_fields {
  created_at: timestamptz
  description: String
  pk: uuid
  project_pk: uuid
  title: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "task"
"""
input task_max_order_by {
  created_at: order_by
  description: order_by
  pk: order_by
  project_pk: order_by
  title: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type task_min_fields {
  created_at: timestamptz
  description: String
  pk: uuid
  project_pk: uuid
  title: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "task"
"""
input task_min_order_by {
  created_at: order_by
  description: order_by
  pk: order_by
  project_pk: order_by
  title: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "task"
"""
type task_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [task!]!
}

"""
input type for inserting object relation for remote table "task"
"""
input task_obj_rel_insert_input {
  data: task_insert_input!

  """upsert condition"""
  on_conflict: task_on_conflict
}

"""
on_conflict condition type for table "task"
"""
input task_on_conflict {
  constraint: task_constraint!
  update_columns: [task_update_column!]! = []
  where: task_bool_exp
}

"""Ordering options when selecting data from "task"."""
input task_order_by {
  created_at: order_by
  description: order_by
  estimates_aggregate: estimate_aggregate_order_by
  pk: order_by
  progresses_aggregate: progress_aggregate_order_by
  project: project_order_by
  project_pk: order_by
  title: order_by
  updated_at: order_by
  user_tasks_aggregate: user_task_aggregate_order_by
}

"""primary key columns input for table: task"""
input task_pk_columns_input {
  pk: uuid!
}

"""
select columns of table "task"
"""
enum task_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  pk

  """column name"""
  project_pk

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "task"
"""
input task_set_input {
  created_at: timestamptz
  description: String
  pk: uuid
  project_pk: uuid
  title: String
  updated_at: timestamptz
}

"""
columns and relationships of "task_status"
"""
type task_status implements Node {
  id: ID!
  status: String!

  """An array relationship"""
  user_tasks(
    """distinct select on columns"""
    distinct_on: [user_task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): [user_task!]!

  """An aggregate relationship"""
  user_tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [user_task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): user_task_aggregate!

  """An array relationship connection"""
  user_tasks_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_task_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): user_taskConnection!
}

"""
A Relay connection object on "task_status"
"""
type task_statusConnection {
  edges: [task_statusEdge!]!
  pageInfo: PageInfo!
}

type task_statusEdge {
  cursor: String!
  node: task_status!
}

"""
Boolean expression to filter rows from the table "task_status". All fields are combined with a logical 'AND'.
"""
input task_status_bool_exp {
  _and: [task_status_bool_exp!]
  _not: task_status_bool_exp
  _or: [task_status_bool_exp!]
  status: String_comparison_exp
  user_tasks: user_task_bool_exp
}

"""
unique or primary key constraints on table "task_status"
"""
enum task_status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  task_status_pkey
}

"""
input type for inserting data into table "task_status"
"""
input task_status_insert_input {
  status: String
  user_tasks: user_task_arr_rel_insert_input
}

"""
response of any mutation on the table "task_status"
"""
type task_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [task_status!]!
}

"""
input type for inserting object relation for remote table "task_status"
"""
input task_status_obj_rel_insert_input {
  data: task_status_insert_input!

  """upsert condition"""
  on_conflict: task_status_on_conflict
}

"""
on_conflict condition type for table "task_status"
"""
input task_status_on_conflict {
  constraint: task_status_constraint!
  update_columns: [task_status_update_column!]! = []
  where: task_status_bool_exp
}

"""Ordering options when selecting data from "task_status"."""
input task_status_order_by {
  status: order_by
  user_tasks_aggregate: user_task_aggregate_order_by
}

"""primary key columns input for table: task_status"""
input task_status_pk_columns_input {
  status: String!
}

"""
select columns of table "task_status"
"""
enum task_status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "task_status"
"""
input task_status_set_input {
  status: String
}

"""
update columns of table "task_status"
"""
enum task_status_update_column {
  """column name"""
  status
}

input task_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: task_status_set_input
  where: task_status_bool_exp!
}

"""
update columns of table "task"
"""
enum task_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  pk

  """column name"""
  project_pk

  """column name"""
  title

  """column name"""
  updated_at
}

input task_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: task_set_input
  where: task_bool_exp!
}

"""
columns and relationships of "tenant"
"""
type tenant implements Node {
  """An object relationship"""
  admin: user!
  admin_pk: uuid!
  created_at: timestamptz!
  description: String!
  id: ID!
  name: String!
  pk: uuid!

  """An array relationship"""
  projects(
    """distinct select on columns"""
    distinct_on: [project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [project_order_by!]

    """filter the rows returned"""
    where: project_bool_exp
  ): [project!]!

  """An aggregate relationship"""
  projects_aggregate(
    """distinct select on columns"""
    distinct_on: [project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [project_order_by!]

    """filter the rows returned"""
    where: project_bool_exp
  ): project_aggregate!

  """An array relationship connection"""
  projects_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [project_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [project_order_by!]

    """filter the rows returned"""
    where: project_bool_exp
  ): projectConnection!
  updated_at: timestamptz!

  """An array relationship"""
  user_tenants(
    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): [user_tenant!]!

  """An aggregate relationship"""
  user_tenants_aggregate(
    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): user_tenant_aggregate!

  """An array relationship connection"""
  user_tenants_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): user_tenantConnection!
}

"""
A Relay connection object on "tenant"
"""
type tenantConnection {
  edges: [tenantEdge!]!
  pageInfo: PageInfo!
}

type tenantEdge {
  cursor: String!
  node: tenant!
}

"""
aggregated selection of "tenant"
"""
type tenant_aggregate {
  aggregate: tenant_aggregate_fields
  nodes: [tenant!]!
}

"""
aggregate fields of "tenant"
"""
type tenant_aggregate_fields {
  count(columns: [tenant_select_column!], distinct: Boolean): Int!
  max: tenant_max_fields
  min: tenant_min_fields
}

"""
order by aggregate values of table "tenant"
"""
input tenant_aggregate_order_by {
  count: order_by
  max: tenant_max_order_by
  min: tenant_min_order_by
}

"""
input type for inserting array relation for remote table "tenant"
"""
input tenant_arr_rel_insert_input {
  data: [tenant_insert_input!]!

  """upsert condition"""
  on_conflict: tenant_on_conflict
}

"""
Boolean expression to filter rows from the table "tenant". All fields are combined with a logical 'AND'.
"""
input tenant_bool_exp {
  _and: [tenant_bool_exp!]
  _not: tenant_bool_exp
  _or: [tenant_bool_exp!]
  admin: user_bool_exp
  admin_pk: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  name: String_comparison_exp
  pk: uuid_comparison_exp
  projects: project_bool_exp
  updated_at: timestamptz_comparison_exp
  user_tenants: user_tenant_bool_exp
}

"""
unique or primary key constraints on table "tenant"
"""
enum tenant_constraint {
  """
  unique or primary key constraint on columns "pk"
  """
  tenant_pkey
}

"""
input type for inserting data into table "tenant"
"""
input tenant_insert_input {
  admin: user_obj_rel_insert_input
  admin_pk: uuid
  created_at: timestamptz
  description: String
  name: String
  pk: uuid
  projects: project_arr_rel_insert_input
  updated_at: timestamptz
  user_tenants: user_tenant_arr_rel_insert_input
}

"""aggregate max on columns"""
type tenant_max_fields {
  admin_pk: uuid
  created_at: timestamptz
  description: String
  name: String
  pk: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "tenant"
"""
input tenant_max_order_by {
  admin_pk: order_by
  created_at: order_by
  description: order_by
  name: order_by
  pk: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type tenant_min_fields {
  admin_pk: uuid
  created_at: timestamptz
  description: String
  name: String
  pk: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "tenant"
"""
input tenant_min_order_by {
  admin_pk: order_by
  created_at: order_by
  description: order_by
  name: order_by
  pk: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "tenant"
"""
type tenant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tenant!]!
}

"""
input type for inserting object relation for remote table "tenant"
"""
input tenant_obj_rel_insert_input {
  data: tenant_insert_input!

  """upsert condition"""
  on_conflict: tenant_on_conflict
}

"""
on_conflict condition type for table "tenant"
"""
input tenant_on_conflict {
  constraint: tenant_constraint!
  update_columns: [tenant_update_column!]! = []
  where: tenant_bool_exp
}

"""Ordering options when selecting data from "tenant"."""
input tenant_order_by {
  admin: user_order_by
  admin_pk: order_by
  created_at: order_by
  description: order_by
  name: order_by
  pk: order_by
  projects_aggregate: project_aggregate_order_by
  updated_at: order_by
  user_tenants_aggregate: user_tenant_aggregate_order_by
}

"""primary key columns input for table: tenant"""
input tenant_pk_columns_input {
  pk: uuid!
}

"""
select columns of table "tenant"
"""
enum tenant_select_column {
  """column name"""
  admin_pk

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  name

  """column name"""
  pk

  """column name"""
  updated_at
}

"""
input type for updating data in table "tenant"
"""
input tenant_set_input {
  admin_pk: uuid
  created_at: timestamptz
  description: String
  name: String
  pk: uuid
  updated_at: timestamptz
}

"""
update columns of table "tenant"
"""
enum tenant_update_column {
  """column name"""
  admin_pk

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  name

  """column name"""
  pk

  """column name"""
  updated_at
}

input tenant_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: tenant_set_input
  where: tenant_bool_exp!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user"
"""
type user implements Node {
  created_at: timestamptz!
  email: String!
  email_md5: String

  """An array relationship"""
  estimates(
    """distinct select on columns"""
    distinct_on: [estimate_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [estimate_order_by!]

    """filter the rows returned"""
    where: estimate_bool_exp
  ): [estimate!]!

  """An aggregate relationship"""
  estimates_aggregate(
    """distinct select on columns"""
    distinct_on: [estimate_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [estimate_order_by!]

    """filter the rows returned"""
    where: estimate_bool_exp
  ): estimate_aggregate!

  """An array relationship connection"""
  estimates_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [estimate_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [estimate_order_by!]

    """filter the rows returned"""
    where: estimate_bool_exp
  ): estimateConnection!

  """An array relationship"""
  fcm_tokens(
    """distinct select on columns"""
    distinct_on: [fcm_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fcm_token_order_by!]

    """filter the rows returned"""
    where: fcm_token_bool_exp
  ): [fcm_token!]!

  """An aggregate relationship"""
  fcm_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [fcm_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fcm_token_order_by!]

    """filter the rows returned"""
    where: fcm_token_bool_exp
  ): fcm_token_aggregate!

  """An array relationship connection"""
  fcm_tokens_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [fcm_token_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [fcm_token_order_by!]

    """filter the rows returned"""
    where: fcm_token_bool_exp
  ): fcm_tokenConnection!
  id: ID!

  """An array relationship"""
  integration_tokens(
    """distinct select on columns"""
    distinct_on: [integration_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_token_order_by!]

    """filter the rows returned"""
    where: integration_token_bool_exp
  ): [integration_token!]!

  """An aggregate relationship"""
  integration_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [integration_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_token_order_by!]

    """filter the rows returned"""
    where: integration_token_bool_exp
  ): integration_token_aggregate!

  """An array relationship connection"""
  integration_tokens_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [integration_token_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [integration_token_order_by!]

    """filter the rows returned"""
    where: integration_token_bool_exp
  ): integration_tokenConnection!
  pk: uuid!

  """An array relationship"""
  progresses(
    """distinct select on columns"""
    distinct_on: [progress_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): [progress!]!

  """An aggregate relationship"""
  progresses_aggregate(
    """distinct select on columns"""
    distinct_on: [progress_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): progress_aggregate!

  """An array relationship connection"""
  progresses_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [progress_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [progress_order_by!]

    """filter the rows returned"""
    where: progress_bool_exp
  ): progressConnection!

  """An array relationship"""
  tenants(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): [tenant!]!

  """An aggregate relationship"""
  tenants_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): tenant_aggregate!

  """An array relationship connection"""
  tenants_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [tenant_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): tenantConnection!
  updated_at: timestamptz!

  """An array relationship"""
  user_projects(
    """distinct select on columns"""
    distinct_on: [user_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_project_order_by!]

    """filter the rows returned"""
    where: user_project_bool_exp
  ): [user_project!]!

  """An aggregate relationship"""
  user_projects_aggregate(
    """distinct select on columns"""
    distinct_on: [user_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_project_order_by!]

    """filter the rows returned"""
    where: user_project_bool_exp
  ): user_project_aggregate!

  """An array relationship connection"""
  user_projects_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_project_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_project_order_by!]

    """filter the rows returned"""
    where: user_project_bool_exp
  ): user_projectConnection!

  """An array relationship"""
  user_tasks(
    """distinct select on columns"""
    distinct_on: [user_task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): [user_task!]!

  """An aggregate relationship"""
  user_tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [user_task_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): user_task_aggregate!

  """An array relationship connection"""
  user_tasks_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_task_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_task_order_by!]

    """filter the rows returned"""
    where: user_task_bool_exp
  ): user_taskConnection!

  """An array relationship"""
  user_tenants(
    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): [user_tenant!]!

  """An aggregate relationship"""
  user_tenants_aggregate(
    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): user_tenant_aggregate!

  """An array relationship connection"""
  user_tenants_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): user_tenantConnection!
  username: String!
}

"""
A Relay connection object on "user"
"""
type userConnection {
  edges: [userEdge!]!
  pageInfo: PageInfo!
}

type userEdge {
  cursor: String!
  node: user!
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  email_md5: String_comparison_exp
  estimates: estimate_bool_exp
  fcm_tokens: fcm_token_bool_exp
  integration_tokens: integration_token_bool_exp
  pk: uuid_comparison_exp
  progresses: progress_bool_exp
  tenants: tenant_bool_exp
  updated_at: timestamptz_comparison_exp
  user_projects: user_project_bool_exp
  user_tasks: user_task_bool_exp
  user_tenants: user_tenant_bool_exp
  username: String_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  user_email_key

  """
  unique or primary key constraint on columns "pk"
  """
  user_pkey

  """
  unique or primary key constraint on columns "username"
  """
  user_username_key
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  created_at: timestamptz
  email: String
  email_md5: String
  estimates: estimate_arr_rel_insert_input
  fcm_tokens: fcm_token_arr_rel_insert_input
  integration_tokens: integration_token_arr_rel_insert_input
  pk: uuid
  progresses: progress_arr_rel_insert_input
  tenants: tenant_arr_rel_insert_input
  updated_at: timestamptz
  user_projects: user_project_arr_rel_insert_input
  user_tasks: user_task_arr_rel_insert_input
  user_tenants: user_tenant_arr_rel_insert_input
  username: String
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  created_at: order_by
  email: order_by
  email_md5: order_by
  estimates_aggregate: estimate_aggregate_order_by
  fcm_tokens_aggregate: fcm_token_aggregate_order_by
  integration_tokens_aggregate: integration_token_aggregate_order_by
  pk: order_by
  progresses_aggregate: progress_aggregate_order_by
  tenants_aggregate: tenant_aggregate_order_by
  updated_at: order_by
  user_projects_aggregate: user_project_aggregate_order_by
  user_tasks_aggregate: user_task_aggregate_order_by
  user_tenants_aggregate: user_tenant_aggregate_order_by
  username: order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  pk: uuid!
}

"""
columns and relationships of "user_project"
"""
type user_project implements Node {
  created_at: timestamptz!
  id: ID!
  pk: uuid!

  """An object relationship"""
  project: project!
  project_pk: uuid!
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_pk: uuid!
}

"""
A Relay connection object on "user_project"
"""
type user_projectConnection {
  edges: [user_projectEdge!]!
  pageInfo: PageInfo!
}

type user_projectEdge {
  cursor: String!
  node: user_project!
}

"""
aggregated selection of "user_project"
"""
type user_project_aggregate {
  aggregate: user_project_aggregate_fields
  nodes: [user_project!]!
}

"""
aggregate fields of "user_project"
"""
type user_project_aggregate_fields {
  count(columns: [user_project_select_column!], distinct: Boolean): Int!
  max: user_project_max_fields
  min: user_project_min_fields
}

"""
order by aggregate values of table "user_project"
"""
input user_project_aggregate_order_by {
  count: order_by
  max: user_project_max_order_by
  min: user_project_min_order_by
}

"""
input type for inserting array relation for remote table "user_project"
"""
input user_project_arr_rel_insert_input {
  data: [user_project_insert_input!]!

  """upsert condition"""
  on_conflict: user_project_on_conflict
}

"""
Boolean expression to filter rows from the table "user_project". All fields are combined with a logical 'AND'.
"""
input user_project_bool_exp {
  _and: [user_project_bool_exp!]
  _not: user_project_bool_exp
  _or: [user_project_bool_exp!]
  created_at: timestamptz_comparison_exp
  pk: uuid_comparison_exp
  project: project_bool_exp
  project_pk: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_pk: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_project"
"""
enum user_project_constraint {
  """
  unique or primary key constraint on columns "pk"
  """
  user_project_pkey
}

"""
input type for inserting data into table "user_project"
"""
input user_project_insert_input {
  created_at: timestamptz
  pk: uuid
  project: project_obj_rel_insert_input
  project_pk: uuid
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_pk: uuid
}

"""aggregate max on columns"""
type user_project_max_fields {
  created_at: timestamptz
  pk: uuid
  project_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by max() on columns of table "user_project"
"""
input user_project_max_order_by {
  created_at: order_by
  pk: order_by
  project_pk: order_by
  updated_at: order_by
  user_pk: order_by
}

"""aggregate min on columns"""
type user_project_min_fields {
  created_at: timestamptz
  pk: uuid
  project_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by min() on columns of table "user_project"
"""
input user_project_min_order_by {
  created_at: order_by
  pk: order_by
  project_pk: order_by
  updated_at: order_by
  user_pk: order_by
}

"""
response of any mutation on the table "user_project"
"""
type user_project_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_project!]!
}

"""
on_conflict condition type for table "user_project"
"""
input user_project_on_conflict {
  constraint: user_project_constraint!
  update_columns: [user_project_update_column!]! = []
  where: user_project_bool_exp
}

"""Ordering options when selecting data from "user_project"."""
input user_project_order_by {
  created_at: order_by
  pk: order_by
  project: project_order_by
  project_pk: order_by
  updated_at: order_by
  user: user_order_by
  user_pk: order_by
}

"""primary key columns input for table: user_project"""
input user_project_pk_columns_input {
  pk: uuid!
}

"""
select columns of table "user_project"
"""
enum user_project_select_column {
  """column name"""
  created_at

  """column name"""
  pk

  """column name"""
  project_pk

  """column name"""
  updated_at

  """column name"""
  user_pk
}

"""
input type for updating data in table "user_project"
"""
input user_project_set_input {
  created_at: timestamptz
  pk: uuid
  project_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
update columns of table "user_project"
"""
enum user_project_update_column {
  """column name"""
  created_at

  """column name"""
  pk

  """column name"""
  project_pk

  """column name"""
  updated_at

  """column name"""
  user_pk
}

input user_project_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_project_set_input
  where: user_project_bool_exp!
}

"""
columns and relationships of "user_role"
"""
type user_role implements Node {
  id: ID!
  role: String!

  """An array relationship"""
  user_tenants(
    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): [user_tenant!]!

  """An aggregate relationship"""
  user_tenants_aggregate(
    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): user_tenant_aggregate!

  """An array relationship connection"""
  user_tenants_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [user_tenant_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [user_tenant_order_by!]

    """filter the rows returned"""
    where: user_tenant_bool_exp
  ): user_tenantConnection!
}

"""
A Relay connection object on "user_role"
"""
type user_roleConnection {
  edges: [user_roleEdge!]!
  pageInfo: PageInfo!
}

type user_roleEdge {
  cursor: String!
  node: user_role!
}

"""
Boolean expression to filter rows from the table "user_role". All fields are combined with a logical 'AND'.
"""
input user_role_bool_exp {
  _and: [user_role_bool_exp!]
  _not: user_role_bool_exp
  _or: [user_role_bool_exp!]
  role: String_comparison_exp
  user_tenants: user_tenant_bool_exp
}

"""
unique or primary key constraints on table "user_role"
"""
enum user_role_constraint {
  """
  unique or primary key constraint on columns "role"
  """
  user_role_pkey
}

"""
input type for inserting data into table "user_role"
"""
input user_role_insert_input {
  role: String
  user_tenants: user_tenant_arr_rel_insert_input
}

"""
response of any mutation on the table "user_role"
"""
type user_role_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_role!]!
}

"""
input type for inserting object relation for remote table "user_role"
"""
input user_role_obj_rel_insert_input {
  data: user_role_insert_input!

  """upsert condition"""
  on_conflict: user_role_on_conflict
}

"""
on_conflict condition type for table "user_role"
"""
input user_role_on_conflict {
  constraint: user_role_constraint!
  update_columns: [user_role_update_column!]! = []
  where: user_role_bool_exp
}

"""Ordering options when selecting data from "user_role"."""
input user_role_order_by {
  role: order_by
  user_tenants_aggregate: user_tenant_aggregate_order_by
}

"""primary key columns input for table: user_role"""
input user_role_pk_columns_input {
  role: String!
}

"""
select columns of table "user_role"
"""
enum user_role_select_column {
  """column name"""
  role
}

"""
input type for updating data in table "user_role"
"""
input user_role_set_input {
  role: String
}

"""
update columns of table "user_role"
"""
enum user_role_update_column {
  """column name"""
  role
}

input user_role_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_role_set_input
  where: user_role_bool_exp!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  email_md5

  """column name"""
  pk

  """column name"""
  updated_at

  """column name"""
  username
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  created_at: timestamptz
  email: String
  email_md5: String
  pk: uuid
  updated_at: timestamptz
  username: String
}

"""
columns and relationships of "user_task"
"""
type user_task implements Node {
  created_at: timestamptz!
  id: ID!
  pk: uuid!

  """An object relationship"""
  project: project!
  project_pk: uuid!
  status: String!

  """An object relationship"""
  task: task!
  task_pk: uuid!

  """An object relationship"""
  task_status: task_status!
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_pk: uuid!
}

"""
A Relay connection object on "user_task"
"""
type user_taskConnection {
  edges: [user_taskEdge!]!
  pageInfo: PageInfo!
}

type user_taskEdge {
  cursor: String!
  node: user_task!
}

"""
aggregated selection of "user_task"
"""
type user_task_aggregate {
  aggregate: user_task_aggregate_fields
  nodes: [user_task!]!
}

"""
aggregate fields of "user_task"
"""
type user_task_aggregate_fields {
  count(columns: [user_task_select_column!], distinct: Boolean): Int!
  max: user_task_max_fields
  min: user_task_min_fields
}

"""
order by aggregate values of table "user_task"
"""
input user_task_aggregate_order_by {
  count: order_by
  max: user_task_max_order_by
  min: user_task_min_order_by
}

"""
input type for inserting array relation for remote table "user_task"
"""
input user_task_arr_rel_insert_input {
  data: [user_task_insert_input!]!

  """upsert condition"""
  on_conflict: user_task_on_conflict
}

"""
Boolean expression to filter rows from the table "user_task". All fields are combined with a logical 'AND'.
"""
input user_task_bool_exp {
  _and: [user_task_bool_exp!]
  _not: user_task_bool_exp
  _or: [user_task_bool_exp!]
  created_at: timestamptz_comparison_exp
  pk: uuid_comparison_exp
  project: project_bool_exp
  project_pk: uuid_comparison_exp
  status: String_comparison_exp
  task: task_bool_exp
  task_pk: uuid_comparison_exp
  task_status: task_status_bool_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_pk: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_task"
"""
enum user_task_constraint {
  """
  unique or primary key constraint on columns "pk"
  """
  user_task_pkey

  """
  unique or primary key constraint on columns "project_pk"
  """
  user_task_project_pk_key

  """
  unique or primary key constraint on columns "task_pk", "status", "user_pk"
  """
  user_task_user_pk_task_pk_status_key
}

"""
input type for inserting data into table "user_task"
"""
input user_task_insert_input {
  created_at: timestamptz
  pk: uuid
  project: project_obj_rel_insert_input
  project_pk: uuid
  status: String
  task: task_obj_rel_insert_input
  task_pk: uuid
  task_status: task_status_obj_rel_insert_input
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_pk: uuid
}

"""aggregate max on columns"""
type user_task_max_fields {
  created_at: timestamptz
  pk: uuid
  project_pk: uuid
  status: String
  task_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by max() on columns of table "user_task"
"""
input user_task_max_order_by {
  created_at: order_by
  pk: order_by
  project_pk: order_by
  status: order_by
  task_pk: order_by
  updated_at: order_by
  user_pk: order_by
}

"""aggregate min on columns"""
type user_task_min_fields {
  created_at: timestamptz
  pk: uuid
  project_pk: uuid
  status: String
  task_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by min() on columns of table "user_task"
"""
input user_task_min_order_by {
  created_at: order_by
  pk: order_by
  project_pk: order_by
  status: order_by
  task_pk: order_by
  updated_at: order_by
  user_pk: order_by
}

"""
response of any mutation on the table "user_task"
"""
type user_task_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_task!]!
}

"""
input type for inserting object relation for remote table "user_task"
"""
input user_task_obj_rel_insert_input {
  data: user_task_insert_input!

  """upsert condition"""
  on_conflict: user_task_on_conflict
}

"""
on_conflict condition type for table "user_task"
"""
input user_task_on_conflict {
  constraint: user_task_constraint!
  update_columns: [user_task_update_column!]! = []
  where: user_task_bool_exp
}

"""Ordering options when selecting data from "user_task"."""
input user_task_order_by {
  created_at: order_by
  pk: order_by
  project: project_order_by
  project_pk: order_by
  status: order_by
  task: task_order_by
  task_pk: order_by
  task_status: task_status_order_by
  updated_at: order_by
  user: user_order_by
  user_pk: order_by
}

"""primary key columns input for table: user_task"""
input user_task_pk_columns_input {
  pk: uuid!
}

"""
select columns of table "user_task"
"""
enum user_task_select_column {
  """column name"""
  created_at

  """column name"""
  pk

  """column name"""
  project_pk

  """column name"""
  status

  """column name"""
  task_pk

  """column name"""
  updated_at

  """column name"""
  user_pk
}

"""
input type for updating data in table "user_task"
"""
input user_task_set_input {
  created_at: timestamptz
  pk: uuid
  project_pk: uuid
  status: String
  task_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
update columns of table "user_task"
"""
enum user_task_update_column {
  """column name"""
  created_at

  """column name"""
  pk

  """column name"""
  project_pk

  """column name"""
  status

  """column name"""
  task_pk

  """column name"""
  updated_at

  """column name"""
  user_pk
}

input user_task_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_task_set_input
  where: user_task_bool_exp!
}

"""
columns and relationships of "user_tenant"
"""
type user_tenant implements Node {
  created_at: timestamptz!
  id: ID!
  pk: uuid!
  role: String!

  """An object relationship"""
  tenant: tenant!
  tenant_pk: uuid!
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_pk: uuid!

  """An object relationship"""
  user_role: user_role!
}

"""
A Relay connection object on "user_tenant"
"""
type user_tenantConnection {
  edges: [user_tenantEdge!]!
  pageInfo: PageInfo!
}

type user_tenantEdge {
  cursor: String!
  node: user_tenant!
}

"""
aggregated selection of "user_tenant"
"""
type user_tenant_aggregate {
  aggregate: user_tenant_aggregate_fields
  nodes: [user_tenant!]!
}

"""
aggregate fields of "user_tenant"
"""
type user_tenant_aggregate_fields {
  count(columns: [user_tenant_select_column!], distinct: Boolean): Int!
  max: user_tenant_max_fields
  min: user_tenant_min_fields
}

"""
order by aggregate values of table "user_tenant"
"""
input user_tenant_aggregate_order_by {
  count: order_by
  max: user_tenant_max_order_by
  min: user_tenant_min_order_by
}

"""
input type for inserting array relation for remote table "user_tenant"
"""
input user_tenant_arr_rel_insert_input {
  data: [user_tenant_insert_input!]!

  """upsert condition"""
  on_conflict: user_tenant_on_conflict
}

"""
Boolean expression to filter rows from the table "user_tenant". All fields are combined with a logical 'AND'.
"""
input user_tenant_bool_exp {
  _and: [user_tenant_bool_exp!]
  _not: user_tenant_bool_exp
  _or: [user_tenant_bool_exp!]
  created_at: timestamptz_comparison_exp
  pk: uuid_comparison_exp
  role: String_comparison_exp
  tenant: tenant_bool_exp
  tenant_pk: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_pk: uuid_comparison_exp
  user_role: user_role_bool_exp
}

"""
unique or primary key constraints on table "user_tenant"
"""
enum user_tenant_constraint {
  """
  unique or primary key constraint on columns "pk"
  """
  user_tenant_pkey
}

"""
input type for inserting data into table "user_tenant"
"""
input user_tenant_insert_input {
  created_at: timestamptz
  pk: uuid
  role: String
  tenant: tenant_obj_rel_insert_input
  tenant_pk: uuid
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_pk: uuid
  user_role: user_role_obj_rel_insert_input
}

"""aggregate max on columns"""
type user_tenant_max_fields {
  created_at: timestamptz
  pk: uuid
  role: String
  tenant_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by max() on columns of table "user_tenant"
"""
input user_tenant_max_order_by {
  created_at: order_by
  pk: order_by
  role: order_by
  tenant_pk: order_by
  updated_at: order_by
  user_pk: order_by
}

"""aggregate min on columns"""
type user_tenant_min_fields {
  created_at: timestamptz
  pk: uuid
  role: String
  tenant_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
order by min() on columns of table "user_tenant"
"""
input user_tenant_min_order_by {
  created_at: order_by
  pk: order_by
  role: order_by
  tenant_pk: order_by
  updated_at: order_by
  user_pk: order_by
}

"""
response of any mutation on the table "user_tenant"
"""
type user_tenant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_tenant!]!
}

"""
on_conflict condition type for table "user_tenant"
"""
input user_tenant_on_conflict {
  constraint: user_tenant_constraint!
  update_columns: [user_tenant_update_column!]! = []
  where: user_tenant_bool_exp
}

"""Ordering options when selecting data from "user_tenant"."""
input user_tenant_order_by {
  created_at: order_by
  pk: order_by
  role: order_by
  tenant: tenant_order_by
  tenant_pk: order_by
  updated_at: order_by
  user: user_order_by
  user_pk: order_by
  user_role: user_role_order_by
}

"""primary key columns input for table: user_tenant"""
input user_tenant_pk_columns_input {
  pk: uuid!
}

"""
select columns of table "user_tenant"
"""
enum user_tenant_select_column {
  """column name"""
  created_at

  """column name"""
  pk

  """column name"""
  role

  """column name"""
  tenant_pk

  """column name"""
  updated_at

  """column name"""
  user_pk
}

"""
input type for updating data in table "user_tenant"
"""
input user_tenant_set_input {
  created_at: timestamptz
  pk: uuid
  role: String
  tenant_pk: uuid
  updated_at: timestamptz
  user_pk: uuid
}

"""
update columns of table "user_tenant"
"""
enum user_tenant_update_column {
  """column name"""
  created_at

  """column name"""
  pk

  """column name"""
  role

  """column name"""
  tenant_pk

  """column name"""
  updated_at

  """column name"""
  user_pk
}

input user_tenant_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_tenant_set_input
  where: user_tenant_bool_exp!
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  email_md5

  """column name"""
  pk

  """column name"""
  updated_at

  """column name"""
  username
}

input user_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input
  where: user_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

